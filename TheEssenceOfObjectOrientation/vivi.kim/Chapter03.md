## Chapter 03. 타입과 추상화

> 추상화는 동적인 객체들을 단순화시켜 정적인 "타입"으로 갈무리하는 것이다.



## 객체지향과 추상화

### 추상화(Abstraction)

* **추상화**란 *복잡한 것을 더 명확하게 이해하기 위해 세부 사항을 감춤으로써 복잡도를 극복하는 방법*
  * 객체지향 패러다임은 **객체**라는 **추상화**를 통해 **현실의 복잡성**을 극복한다.
* 훌륭한 추상화는 **목적에 부합**하는 것이어야 한다.
* 추상화는 두 개의 차원에서 이루어진다.
  * <u>**일반화**</u> - 구체적인 사물들 간의 공통점은 취하고 차이점은 버리는 것
  * ***강조와 제거*** - 중요한 부분을 강조하기 위해 불필요한 세부사항을 제거



### 개념(Concept)

* **개념**이란 *공통점을 기반으로 객체를 분류해 복잡성을 극복할 수 있는 **추상화 도구***
  * 개념의 사전적 정의: 일반적으로 인식할 수 있는 다양한 사물이나 객체에 적용할 수 있는 아이디어 또는 관념
* 개념을 사용해 여러 객체를 **분류(Classification)**할 수 있다.
  * 적절한 분류 체계는 소프트웨어 개발자가 객체를 다루는 데 더 쉽게 만드므로 객체지향의 품질을 향상시킨다.
* 분류를 통해 어떤 개념 안에 포함된 객체를 **인스턴스(Instance)**라고 한다.

* 개념의 세 가지 관점
  * 심볼(Symbol) - 개념을 가리키는 이름
  * 내연(Intension) - 개념의 의미
  * 외연(Extension) - 개념에 속하는 객체 집합





## 객체지향과 타입

### 타입

* **타입**이란 *개념의 동의어*
  * 개념과 마찬가지로 심볼, 내연, 외연을 이용해 서술 가능
  * **타입에 속하는 객체** = 타입의 **인스턴스**



* **데이터 타입**
  * **데이터 타입**이란 *컴퓨터 메모리 안에 저장된 데이터의 종류를 분류하는 데 사용하는 메모리 집합에 관한 메타데이터*
  * 데이터에 대한 분류는 암시적으로 어떤 종류의 연산이 해당 데이터에 대해 수행될 수 있는지를 결정한다. (특정한 역할은 특정한 책임을 암시한다)
  * **타입 시스템(Type System)**
    * **타입 시스템**이란 *컴퓨터 메모리 안의 데이터에 부여된 특정한 의미가 만들어낸 체계*
    * 데이터가 잘못 사용되지 않도록 제약사항을 부과하는 목적을 지님



* **타입의 두 가지 특징**
  * 타입은 데이터가 어떻게 사용되느냐에 관한 것이다.
    * 어떤 데이터에 <u>어떤 연산자를 적용할 수 있는가</u>가 그 데이터의 타입을 결정한다.
  * 타입에 속한 데이터가 메모리에 어떻게 표현되는지는 <u>감춰진다</u>.
    * 타입은 캡슐화 되어 있다.



### 객체와 타입

* 소프트웨어 개발자는 객체를 일종의 데이터처럼 사용한다.
  * 그렇다면 객체는 데이터인가? -> XXX
  * 객체에서 중요한 것은 **객체의 행동**, 데이터는 단지 객체의 상태를 쉽게 표현하기 위한 수단일 뿐

* 타입의 특징으로 바라보는 **객체의 타입의 특징**
  * 어떤 객체가 어떤 타입에 속하는지 정하는 것은 <u>객체가 수행하는 행동</u>에 따라 달라진다.
  * 객체의 내부적인 표현은 외부로부터 철저하게 <u>감춰진다</u>.

* **동일한 타입으로 분류된 객체**들이 메시지를 처리하는 방식은 서로 다를 수 있다.
  * 동일한 <u>타입으로 분류</u>된다는 것 = 동일한 <u>책임을 가진다</u>는 것 = 동일한 <u>방식으로 행동했다</u>는 것
  * 메시지에 대해 서로 다른 방식으로 응답하는 능력 - <u>다형성(Polymorphism)</u>





## 타입과 추상화

### 타입의 일반화를 통한 계층 관계

* 타입은 **일반화/특수화(Generalization/Specialization) 관계**를 가질 수 있다.
  * 좀 더 일반적인 타입의 **슈퍼타입(Supertype)**과 좀 더 특수한 타입인 **서브타입(Subtype)**의 관계
* 일반화와 특수화는 동시에 일어난다.
  * 일반화/특수화는 두 타입에 대한 상대적인 비교이기 때문이다.
* **특수한 타입은 일반 타입이 할 수 있는 행동을 모두 수행할 수 있어야 한다**. (행위적 호환성)
  * 일반화/특수화는 **행동에 관한 관계 정의**다.
  * 어떤 타입을 다른 타입의 서브타입이라고 말할 수 있으려면 다른 타입을 대체할 수 있어야 한다. (LSP)



* **일반화는 추상화를 위한 도구**다.
  * 다시보는 추상화의 두 개의 차원
    * <u>**일반화**</u> - 객체의 행동을 중심으로 한 **분류**를 통해 객체들의 공통점을 취하고 차이점을 버림
    * <u>**강조와 제거**</u> - 불필요한 특성을 **특수화** 시키고 포괄적인 특징을 **일반화**



* 타입의 목적

  * 시간에 따라 <u>동적으로 변하는 객체의 복잡성</u>을 

    시간에 독립적인 <u>타입이라는 정적인 모습</u>으로 다룰 수 있게 하기 위함

    * 특정 시점의 객체가 가지는 상태 - 스냅샷(<u>동적 모델</u>)
    * 객체가 속한 타입의 정적인 모습 - 타입 모델(<u>정적 모델</u>)

  * 즉, **타입을 이용해 객체를 동적인 특성을 추상화**할 수 있다.

  * 객체를 분류하기 위한 기준

    * 타입을 나누는 기준: 객체가 수행하는 행동



* 클래스(Class)
  * 클래스는 타입인가? -> XXX
  * 클래스는 단지 타입을 구현하기 위한 여러 구현 메커니즘 중 하나일 뿐